[
    {is_ready, [
        {port, {{ corezoid_api_sync_is_ready_port }}},
        {disabled, {{ corezoid_api_sync_is_ready_disabled }}}
    ]},

    %% Default application min & max epmd ports for cluster solution
    {kernel, [
        {inet_dist_listen_min, {{ corezoid_api_sync_kernel_inet_dist_listen_min }}},
        {inet_dist_listen_max, {{ corezoid_api_sync_kernel_inet_dist_listen_max }}}
    ]},

    {dns_cache, [
        {servers, [
{% for item in rmq_core %}
            [
                {name, {{ item.dns_cache_name }}},
                {dns, "{{ item.host }}"},
                {ttl, {{ dns_cache_ttl | default(60) }}}
            ],
{% endfor %}
            [
                {name, {{ rmq_http[0].dns_cache_name }}},
                {dns, "{{ rmq_http[0].host }}"},
                {ttl, {{ dns_cache_ttl | default(60) }}}
            ]
        ]}
    ]},

    {ermql, [

        {publish_request, [
            {servers, [
                [
                    %%{dns_name, {{ rmq_http[0].dns_cache_name }}},
                    {host, "{{ rmq_http[0].host }}"},
                    {port, {{ rmq_http[0].port }}},
                    {username, <<"{{ rmq_http[0].user }}">>},
                    {password, <<"{{ rmq_http[0].pass }}">>},
                    {vhost, <<"{{ rmq_vhost }}">>}
                ]
            ]},
            {queues_count, 1},
            {min_size, 1},
            {max_size, 1},
            {start_size, 1}
        ]},

        {consumer_response, [
            {servers, [
                [
                    %%{dns_name, {{ rmq_http[0].dns_cache_name }}},
                    {host, "{{ rmq_http[0].host }}"},
                    {port, {{ rmq_http[0].port }}},
                    {username, <<"{{ rmq_http[0].user }}">>},
                    {password, <<"{{ rmq_http[0].pass }}">>},
                    {vhost, <<"{{ rmq_vhost }}">>}
                ]
            ]},
            {connections_per_queue, 1},
            {channels_per_connection, 1},
            {messages_prefetch_size_per_channel, 50}
        ]}
    ]},

    {corezoid_api_sync, [
        {nodes, []},
        {domain, <<"https://{{ corezoid_api_sync.domain }}">> }, %% Application url
        {api_port, {{ corezoid_api_sync.app_port }}},
        {corezoid_host, <<"https://{{ capi_endpoint }}">>},
{% if corezoid_api_sync.api_user_id is defined and corezoid_api_sync.api_user_id != "" %}
        {login_id, <<"{{ corezoid_api_sync.api_user_id }}">>},
        {login_secret , <<"{{ corezoid_api_sync.api_user_secret }}">>},
{% endif %}
        %% CALLBACK SETUP
        {callback, [
            {path, <<"/api/1/plugins/callback/">>},         %% Used for generate __callback_url for example host/callback.path/req_id where req_id is autogenerated
            {max_timeout, {{ corezoid_api_sync.max_timeout | default(60000) }}}                            %% Max timeout to receive callbacks - {% if corezoid_api_sync.max_timeout is defined and corezoid_api_sync.api_user_id != "" %}{{ corezoid_api_sync.max_timeout / 1000 }}{% else %}{{ 60000/1000 }}{% endif %} seconds
        ]}
    ]},

    {lager, [
        %% What handlers to install with what arguments
        {log_root, "{{ top_dir }}/erlang/{{ item }}/log"},
        {handlers, [
            {lager_console_backend, info},
            {lager_file_backend, [{file, "error.log"}, {level, error}, {size, 1500000}, {date, "$D0"}, {count, 0}]},
            {lager_file_backend, [{file, "console.log"}, {level, info}, {size, 1500000}, {date, "$D0"}, {count, 0}]}
        ]},

        {extra_sinks,
            [
                {error_logger_lager_event,
                    [{handlers, [
                        {lager_file_backend, [{file, "error_logger.log"}, {level, info}]}]
                    }]
                }
            ]
        },

        %% What colors to use with what log levels
        {colored, true},
        {colors, [
            {debug,     "\e[0;38m" },
            {info,      "\e[1;37m" },
            {notice,    "\e[1;36m" },
            {warning,   "\e[1;33m" },
            {error,     "\e[1;31m" },
            {critical,  "\e[1;35m" },
            {alert,     "\e[1;44m" },
            {emergency, "\e[1;41m" }
        ]},
        %%
        %% Whether to write a crash log, and where. Undefined means no crash logger.
        {crash_log, "crash.log"},
        %% Maximum size in bytes of events in the crash log - defaults to 65536
        {crash_log_msg_size, 65536},
        %% Maximum size of the crash log in bytes, before its rotated, set
        %% to 0 to disable rotation - default is 0
        {crash_log_size, 10485760},
        %% What time to rotate the crash log - default is no time
        %% rotation. See the README for a description of this format.
        {crash_log_date, "$D0"},
        %% Number of rotated crash logs to keep, 0 means keep only the
        %% current one - default is 0
        {crash_log_count, 1},
        %% Whether to redirect error_logger messages into lager - defaults to true
        {error_logger_redirect, true},
        %% How many messages per second to allow from error_logger before we start dropping them
        {error_logger_hwm, 50},
        %% How big the gen_event mailbox can get before it is switched into sync mode
        {async_threshold, 20},
        %% Switch back to async mode, when gen_event mailbox size decrease from `async_threshold'
        %% to async_threshold - async_threshold_window
        {async_threshold_window, 5}
    ]}
].
